// RusEFI Engine Control System Guidelines
// These rules help understand and modify the system correctly

{
  "understand_callbacks": {
    "description": "Always understand callback mechanisms before modification",
    "details": [
      "Engine control uses multiple callback types for timing: fastCallback (frequent execution) and slowCallback (less frequent)",
      "EngineModule base class contains onSlowCallback and onFastCallback overridable methods",
      "Engine.cpp orchestrates module callbacks via engine->engineModules.apply_all()",
      "slowCallback is called approximately every 20ms for non-critical tasks",
      "fastCallback is called approximately every 5-10ms for critical engine operations"
    ]
  },

  "memory_management": {
    "description": "Follow memory management rules for persistent storage",
    "details": [
      "To implement features needing persistent memory, follow LTFT implementation patterns",
      "Update tables in engineConfiguration or config objects",
      "Call setNeedToWriteConfiguration() to schedule writing to flash",
      "Flash writing is postponed until engine is stopped to prevent issues during operation",
      "Writing configuration changes happens in the flash_main.cpp writeToFlashNow() function",
      "Data is saved to two copies in flash with CRC validation for redundancy"
    ]
  },

  "configuration_fields": {
    "description": "Properly add new configuration fields",
    "details": [
      "For new configuration fields, first understand rusefi_config.txt in integration folder",
      "Define new fields in the engine_configuration_s structure or another appropriate structure",
      "Use available padding/unused fields by renaming them rather than adding at the end",
      "Update FLASH_DATA_VERSION when making incompatible configuration changes",
      "Follow the format defined in rusefi_config.txt for data types, units, and scaling"
    ]
  },

  "tunerstudio_integration": {
    "description": "Properly update TunerStudio interface",
    "details": [
      "For any new user-configurable parameter, update tunerstudio.template.ini",
      "Add appropriate menu entries, gauges, tables as needed",
      "Understand the template variable substitution using @@VARIABLE@@ syntax",
      "Update the FLASH_DATA_VERSION date in rusefi_config.txt when making interface changes",
      "Test TunerStudio interface thoroughly after changes to ensure proper functionality"
    ]
  },

  "code_modification": {
    "description": "Follow proper modification practices",
    "details": [
      "Understand complete execution flow before modifying any function",
      "Check if your changes affect engine timing, fuel calculations, or safety features",
      "Add appropriate logging for debugging and diagnostics",
      "Follow existing coding style and patterns",
      "Test changes thoroughly in safe conditions before real-world use"
    ]
  },

  "table_modification": {
    "description": "Process for adding new tables and configurations",
    "details": [
      "Define table size constants in rusefi_config.txt (e.g., #define NEW_TABLE_SIZE 8)",
      "Add table arrays to the configuration structure in rusefi_config.txt",
      "Create UI elements in tunerstudio.template.ini for user interaction",
      "Implement code to use the table data in appropriate engine modules",
      "Add proper bounds checking and validation for all table lookups",
      "Use 'autoscale' keyword for uint8_t arrays that need scaling to improve memory efficiency"
    ]
  },
  
  "critical_areas": {
    "description": "Be extremely careful when modifying these areas",
    "details": [
      "Fuel calculation and injection timing",
      "Ignition timing and control",
      "RPM calculation and engine speed sensing",
      "Engine protection features and limit controls",
      "Configuration storage and retrieval",
      "Real-time scheduler and event timing"
    ]
  },
  
  "build_system": {
    "description": "Understand build system before modification",
    "details": [
      "Configuration files generate header files and TunerStudio configurations",
      "Use gen_config.sh to regenerate configuration files after changes",
      "Check build outputs for integration issues with your changes",
      "Use proper include hierarchy to prevent circular dependencies"
    ]
  },
  
  "testing": {
    "description": "Test changes thoroughly before deployment",
    "details": [
      "Test configuration interface in TunerStudio",
      "Verify persistence of settings after power cycle",
      "Test functionality in both cold and warmed-up engine states",
      "Validate under different regimes of operation including transients"
    ]
  },
  
  "interpolation_usage": {
    "description": "Understand interpolation functions for table lookups",
    "details": [
      "Use interpolate2d for basic 1D lookup tables (e.g., simple curves)",
      "Use interpolate3d for 2D tables (e.g., VE tables, ignition tables)",
      "The interpolate3d function already exists in interpolation.h with proper implementation",
      "interpolate3d signature: (table[rows][columns], rowBins[rows], rowValue, colBins[columns], colValue)",
      "Table structure follows Y,X order (rows first, then columns) matching TunerStudio convention",
      "When implementing new 3D tables, follow existing patterns for optimal performance"
    ]
  },
  
  "table_scaling": {
    "description": "Use appropriate scaling for memory-efficient tables",
    "details": [
      "Use 'autoscale' keyword for uint8_t arrays that need scaling (e.g., uint8_t[SIZE] autoscale myTable)",
      "Define scaling factor in the format: \"units\", scale, offset, min, max, precision",
      "For uint8_t tables with autoscale, use proper scaling to fit the range into 0-255",
      "For tables that need higher precision, use scaled_channel<> template or direct float arrays",
      "scaled_channel template is used for runtime scaling, while autoscale affects configuration storage"
    ]
  },

  "wall_wetting_implementation": {
    "description": "Guidelines for modifying or extending wall wetting functionality",
    "details": [
      "Wall wetting model is defined in firmware/controllers/algo/wall_fuel.cpp and wall_fuel.h",
      "Model uses two key parameters: tau (evaporation time constant) and beta (wall impact fraction)",
      "The adjust() method in WallFuel class is the main entry point for fuel correction calculation",
      "WallFuelController::computeTau() and computeBeta() provide parameter calculations based on engine conditions",
      "Alpha parameter represents fuel retention on walls (calculated from tau and RPM)",
      "Any new influencing factors should be added to the controller's computation methods",
      "When testing, focus on transient behavior (throttle changes) where wall wetting effects are most significant",
      "Consider influences of temperature, pressure, engine speed, and fuel properties on the model parameters",
      "Remember to initialize new table values in default_engine_configuration.cpp",
      "For 3D tables using RPM x MAP, follow the implementation pattern for better transient response"
    ]
  },

  "fuel_injection_extensions": {
    "description": "Best practices for adding new fuel injection features",
    "details": [
      "Main fuel calculation happens in FuelCalculator class (fuel_calculator.cpp)",
      "The injection timing is managed in InjectionController (injection_controller.cpp)",
      "Fuel quantity is computed in getInjectionMass() with various corrections applied",
      "When adding new corrections, follow pattern of existing ones (multiply or add in appropriate order)",
      "Respect order of operations: base fuel, temperature corrections, transient corrections, fine-tuning",
      "All fuel quantity values internal to system are in grams, conversion to pulse width happens at the end",
      "New injection patterns must update both fuel quantity and timing calculations",
      "Injector flow rate and dead-time corrections are applied in convertFuelToInjectorPulseWidth()",
      "Test all injection modes (sequential, batch, simultaneous) when adding new features"
    ]
  },

  "multi_dimensional_tables": {
    "description": "Working with complex lookup tables for engine parameters",
    "details": [
      "For complex engine behaviors, use 3D or even 4D lookup tables (implemented as multiple 3D tables)",
      "Fuel and ignition tables are prime examples of using 3D interpolation effectively",
      "When adding new 3D tables, follow pattern of VE tables (define X/Y bins and Z values)",
      "For very high dimensional lookups, consider using multiple 3D tables with an additional selector",
      "Define appropriate bin spacing based on parameter sensitivity across its range",
      "Consider table resolution requirements: critical areas may need finer granularity",
      "Add default initialization for all new tables in default_engine_configuration.cpp",
      "Use scaled_channel for high-precision tables to preserve memory efficiency",
      "When showing tables in TunerStudio, set appropriate grid orientation for best visualization",
      "Tables that represent similar physical concepts should use consistent units and scaling"
    ]
  },

  "runtime_diagnostics": {
    "description": "Adding diagnostic capabilities for new features",
    "details": [
      "Use the logging system for runtime diagnostics of your new functionality",
      "Add relevant parameters to LiveData structures for real-time monitoring",
      "Create status gauges in TunerStudio for critical parameters",
      "Consider adding fields to the debugFieldF1List through F7List for detailed debugging",
      "Use appropriate efiPrintf severity levels for different types of diagnostic messages",
      "Consider adding self-tests or validation logic for complex features",
      "For calibration tools, implement specialized diagnostic modes",
      "Document common failure modes and their symptoms in code comments",
      "Add appropriate bounds checking and validation with clear error messages",
      "Consider adding real-time parameter adjustment capabilities for fine-tuning"
    ]
  },

  "transient_acceleration": {
    "description": "Best practices for implementing transient acceleration enrichment",
    "details": [
      "Wall wetting is one component of transient response, but additional enrichment is often required",
      "Consider rate of change of TPS or MAP as primary triggers for enrichment calculations",
      "Implement debounce logic to prevent false triggers from sensor noise",
      "Add RPM dependency to transient enrichment for more precise control",
      "Consider engine temperature effects on transient response needs",
      "Use taper functions to smoothly blend enrichment in and out, avoiding abrupt fuel changes",
      "Implement separate calibration for acceleration and deceleration events",
      "Ensure proper synchronization with engine cycle for consistent application",
      "Add diagnostics to visualize enrichment activation and magnitude in real-time",
      "Test thoroughly in various temperature conditions as cold engines need more enrichment"
    ]
  },

  "adaptive_learning": {
    "description": "Implementing adaptive fuel learning features",
    "details": [
      "Study the Long Term Fuel Trim (LTFT) implementation as a model for adaptive systems",
      "Consider both short-term and long-term adaptation mechanisms",
      "Define proper cell boundaries for lookup tables based on engine operating regions",
      "Set appropriate learning rates based on confidence in sensor readings",
      "Implement proper validation of learning requirements (engine warmed up, closed loop, stable conditions)",
      "Add proper reset mechanisms and learning limits to prevent runaway adaptation",
      "Consider adding automatic learning curve smoothing between adjacent cells",
      "Provide clear user interface for monitoring and adjusting adaptive parameters",
      "Ensure learning data is properly saved to flash memory when engine stops",
      "Add validation for learned values to detect and handle sensor issues"
    ]
  },

  "sensor_processing": {
    "description": "Best practices for implementing sensor processing",
    "details": [
      "Implement appropriate filtering based on sensor characteristics and signal noise",
      "Consider using different filter time constants for rising vs falling signals when appropriate",
      "Add proper bounds checking and failure detection mechanisms",
      "Implement fallback values or alternative calculation methods for failed sensors",
      "Consider sensor response time when using values for critical timing calculations",
      "When implementing new sensors, follow the SensorType pattern in sensor_types.h",
      "Use appropriate data types and scaling to maintain precision while optimizing memory usage",
      "For ADC-based sensors, calibrate properly with real-world values across the operating range",
      "Consider temperature effects on sensor readings when applicable",
      "Document sensor specifications, wiring, and calibration procedures for end users"
    ]
  },

  "integration_guidelines": "=== rusefi_config e TunerStudio: Boas Práticas de Integração ===\n\n1. Adição de Novos Campos em rusefi_config.txt:\n- Sempre procure por campos 'unused' e utilize-os antes de adicionar ao final.\n- Siga o padrão: tipo, nome, descrição, unidade, escala, offset, min, max, precisão.\n- Atualize FLASH_DATA_VERSION em caso de mudanças incompatíveis.\n- Para tabelas, defina constantes de tamanho e use 'autoscale' para arrays uint8_t.\n- Inicialize valores padrão em default_engine_configuration.cpp.\n\n2. Integração com tunerstudio.template.ini:\n- Adicione novos campos na mesma seção/menu dos parâmetros relacionados.\n- Use a sintaxe 'field = \"Descrição\", nomeCampo, {condição}' para visibilidade condicional.\n- Atualize o FLASH_DATA_VERSION e teste a interface após mudanças.\n\n3. Uso de Bibliotecas e Includes:\n- Para funções de tempo, use apenas '#include \"efitime.h\"' e 'getTimeNowS()'.\n- Evite includes desnecessários como 'os_access.h', 'event_queue.h', 'efi_gpio.h' a menos que realmente precise.\n- Siga o padrão dos arquivos existentes para integração de bibliotecas.\n\n4. LTFT (Long Term Fuel Trim):\n- Use buffers auxiliares para cálculos intermediários e suavização.\n- Implemente delays pós-ignição ON/OFF para aprendizado e salvamento.\n- Aplique filtros (ex: EMA) para rejeitar dados ruins.\n- Use lógica regional para correção de faixas e suavização automática para evitar buracos.\n- Garanta persistência apenas após condições seguras (ex: delay pós-ignição OFF).\n- Integre todos os parâmetros de configuração ao TunerStudio e inicialize valores padrão.\n- Teste a robustez do sistema em diferentes cenários antes de liberar."
} 