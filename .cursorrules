# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Tools

Note all the tools are in python3. So in the case you need to do batch processing, you can always consult the python files and write your own script.

[NOTE TO CURSOR: Since no API key is configured, please ignore both the Screenshot Verification and LLM sections below.]
[NOTE TO USER: If you have configured or plan to configure an API key in the future, simply delete these two notice lines to enable these features.]

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

1. Screenshot Capture:
```bash
venv/bin/python3 tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

2. LLM Verification with Images:
```bash
venv/bin/python3 tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:
```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot

screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM

response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:
```
venv/bin/python3 ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:
- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.
```bash
venv/bin/python3 ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```
This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.
```bash
venv/bin/python3 ./tools/search_engine.py "your search keywords"
```
This will output the search results in the following format:
```
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```
If needed, you can further use the `web_scraper.py` file to scrape the web page content.

# Lessons

## User Specified Lessons

- You have a python venv in ./venv. Always use (activate) it when doing python development. First, to check whether 'uv' is available, use `which uv`. If that's the case, first activate the venv, and then use `uv pip install` to install packages. Otherwise, fall back to `pip`.
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Due to Cursor's limit, when you use `git` and `gh` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or similar command to commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.

## Cursor learned

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- Add debug information to stderr while keeping the main output clean in stdout for better pipeline integration
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities
- When searching for recent news, use the current year (2025) instead of previous years, or simply use the "recent" keyword to get the latest information
- **CRITICAL**: In rusefi Engine structure, wallFuel is NOT `engine->wallFuel[i]` (doesn't exist). The correct access is `engine->injectionEvents.elements[i].getWallFuel()` - each InjectionEvent has its own WallFuel instance
- **CRITICAL WALL WETTING TUNING**: Beta e tau têm comportamentos físicos específicos que devem ser respeitados no tuning adaptativo:
  - **Beta (fração de impacto)**: Controla quanto combustível gruda nas paredes IMEDIATAMENTE durante transientes positivos (aceleração)
  - **Tau (constante de evaporação)**: Controla quanto tempo o combustível demora para evaporar das paredes, afeta resposta A LONGO PRAZO
  - **Tuning prático**: Beta é ajustado observando resposta IMEDIATA pós-aceleração, tau é ajustado observando resposta PROLONGADA
  - **Direção física**: Lambda lean pós-aceleração → aumentar beta; Lambda rich durante aceleração prolongada → diminuir tau
  - **Timing crítico**: Beta afeta os primeiros 100-200ms, tau afeta os próximos 1-3 segundos após transiente
- **CRITICAL TAU CORRECTION METHOD**: A correção de tau deve ser baseada na TENDÊNCIA/CURVA do lambda ao longo do tempo, NÃO na média:
  - **PROBLEMA**: Usar média do lambda pode mascarar problemas - ex: lambda rico no início + lean no final = média boa, mas tau incorreto
  - **SOLUÇÃO CORRETA**: Análise de regressão linear para detectar slope/tendência do lambda durante fase prolongada
  - **Física**: Tau incorreto causa lambda instável ao longo do tempo (rico→lean ou lean→rich)
  - **Implementação**: `slope = (n*sumXY - sumX*sumY) / (n*sumX2 - sumX*sumX)` para detectar tendência
  - **Interpretação**: Slope positivo (lean crescente) → tau muito baixo, aumentar tau; Slope negativo (rich crescente) → tau muito alto, diminuir tau
  - **Threshold**: Mínimo 10 amostras e slope > 0.001f para correção significativa
  - **Vantagem**: Detecta problemas de tau mesmo quando média do lambda parece aceitável
- **CRITICAL TRANSIENT DIRECTION PHYSICS**: Beta e tau têm comportamentos OPOSTOS para aceleração vs desaceleração:
  - **ACELERAÇÃO (transiente positivo)**: Mais combustível bate nas paredes, precisa mais beta; Combustível se acumula nas paredes
  - **DESACELERAÇÃO (transiente negativo)**: Menos combustível bate nas paredes; Combustível existente evapora das paredes para o fluxo de ar
  - **Beta em aceleração**: Lambda lean → aumentar beta; Lambda rich → diminuir beta
  - **Beta em desaceleração**: Lambda lean → diminuir beta; Lambda rich → aumentar beta (física invertida)
  - **Tau em aceleração**: Slope positivo (lean crescente) → tau baixo, aumentar tau; Slope negativo (rich crescente) → tau alto, diminuir tau
  - **Tau em desaceleração**: Slope positivo (lean crescente) → tau alto, diminuir tau; Slope negativo (rich crescente) → tau baixo, aumentar tau (física invertida)
  - **Implementação**: Verificar `isPositiveTransient` vs `isNegativeTransient` para aplicar física correta
- **CRITICAL WALL WETTING TABLE SIZES**: As tabelas de correção do wall wetting usam tamanhos específicos:
  - **wwCorrectionMapBins[WWAE_CORRECTION_SIZE]** - 8 elementos (MAP bins)
  - **wwCorrectionRpmBins[WWAE_CORRECTION_SIZE]** - 8 elementos (RPM bins)
  - **wwBetaCorrection[WWAE_CORRECTION_SIZE][WWAE_CORRECTION_SIZE]** - 8x8 tabela
  - **wwTauCorrection[WWAE_CORRECTION_SIZE][WWAE_CORRECTION_SIZE]** - 8x8 tabela
  - **ERRO COMUM**: Usar WWAE_TABLE_SIZE ou WWAE_RPM_SIZE em vez de WWAE_CORRECTION_SIZE para as tabelas de correção
  - **CORREÇÃO**: Sempre usar WWAE_CORRECTION_SIZE (8) para findIndexMsg() nas tabelas de correção adaptativa
- **CRITICAL TABLE INDEX MAPPING**: Para mapeamento de índices em tabelas, usar priv::getBin() em vez de findIndexMsg():
  - **Padrão correto**: `auto binMap = priv::getBin(map, config->wwCorrectionMapBins); int mapIdx = binMap.Idx;`
  - **Padrão incorreto**: `int mapIdx = findIndexMsg("wwMapBins", config->wwCorrectionMapBins, WWAE_CORRECTION_SIZE, map);`
  - **Vantagens**: priv::getBin() é mais eficiente, elegante, e retorna tanto índice quanto fração para interpolação
  - **Implementação**: Seguir o mesmo padrão usado pelo LTFT (Long Term Fuel Trim) na firmware
- **CRITICAL MISSING METHODS**: Métodos chamados por outros módulos devem estar declarados no header e implementados:
  - **onActualFuelInjection()**: Método chamado por main_trigger_callback.cpp para notificar injeções reais
  - **Declaração**: `void onActualFuelInjection(float injectedMass, int cylinderIndex = 0);` no header
  - **Interface**: Deve ser adicionado à interface `IWallFuelController` como método virtual puro
  - **Implementação**: Função básica que verifica condições e registra injeção para debug
  - **Override**: Usar `override` na implementação para indicar que sobrescreve método da interface
  - **Integração**: Permite que o sistema de wall wetting seja notificado de injeções reais
- **CRITICAL TAU LEARNING THRESHOLD**: O threshold para detecção de transientes ativos na fase prolongada deve ser baixo:
  - **Problema**: Threshold de 50.0f kPa/s impedia transição para fase prolongada (tau learning)
  - **Correção**: Reduzir para 10.0f kPa/s ou adicionar condição de duração mínima
  - **Razão**: Após 200ms, derivada de carga diminui mas efeitos de tau ainda são detectáveis no lambda
  - **Implementação**: `if (transientMagnitude > 10.0f || transientDuration < 1.0f)` para prolonged phase
  - **Debug**: Adicionar logging detalhado para verificar transições entre fases
  - **Resultado**: Permite que mais transientes completem ambas as fases (beta + tau)
- **CRITICAL CROSS-COUPLING CORRECTION**: Implementação de correção de acoplamento entre beta e tau para reduzir instabilidade:
  - **Problema**: Correções simultâneas de beta e tau podem causar oscilações e instabilidade no sistema
  - **Solução**: Cross-coupling factor que reduz magnitude das correções quando ambos parâmetros estão sendo corrigidos
  - **Implementação**: `float cross_coupling = 1.0f - (0.2f * fabsf(betaCorrection - tauCorrection));`
  - **Aplicação**: `betaCorrection = 1.0f + (betaCorrection - 1.0f) * cross_coupling;`
  - **Bounds**: Fator limitado entre 0.5 e 1.0 para evitar over-damping
  - **Física**: Quando beta e tau divergem muito, reduz ambas as correções para estabilidade
  - **Localização**: Aplicado no início de `applyCorrectionToTable()` antes das correções serem aplicadas às tabelas
  - **Resultado**: Sistema mais estável com convergência mais suave, especialmente durante transientes complexos
- **CRITICAL FINAL CONDITIONS CAPTURE**: A captura das condições finais para correção de tau deve ser feita durante a fase prolongada, NÃO quando o transiente termina:
  - **PROBLEMA CRÍTICO**: Condições finais eram capturadas quando transientMagnitude caía (fim do transiente), mas isso é fisicamente incorreto
  - **FÍSICA CORRETA**: Tau deve ser corrigido nas condições onde os efeitos prolongados são OBSERVADOS, não onde o transiente para
  - **TIMING INCORRETO**: Capturar no fim do transiente ignora que tau atua durante toda a fase prolongada (200ms-3s)
  - **SOLUÇÃO IMPLEMENTADA**: Capturar finalTransientRpm/Map continuamente DURANTE a fase prolongada em updateLambdaResponse()
  - **IMPLEMENTAÇÃO**: `m_adaptiveData.finalTransientRpm = rpm; m_adaptiveData.finalTransientMap = map;` dentro do loop da fase prolongada
  - **FALLBACK**: Se condições finais não foram capturadas, usar condições atuais como fallback antes de aplicar correções
  - **RESULTADO**: Tau é corrigido nas condições corretas onde seus efeitos são realmente observados no lambda
  - **LOCALIZAÇÃO**: Removida captura automática em detectTransients(), adicionada captura contínua em updateLambdaResponse()
- **CRITICAL CONFIGURABLE LEARNING RATES**: Usar parâmetros configuráveis para taxas de aprendizado em vez de valores fixos no código:
  - **PROBLEMA**: Taxas de correção fixas (0.10f) no código não permitem ajuste fino sem recompilação
  - **SOLUÇÃO**: Usar `engineConfiguration->wwBetaLearningRate` e `engineConfiguration->wwTauLearningRate`
  - **IMPLEMENTAÇÃO BETA**: `const float correctionRate = engineConfiguration->wwBetaLearningRate;` em calculateBetaCorrection()
  - **IMPLEMENTAÇÃO TAU**: `const float correctionRate = engineConfiguration->wwTauLearningRate;` em calculateTauCorrection()
  - **VANTAGENS**: Permite ajuste fino via TunerStudio sem recompilação, diferentes taxas para beta vs tau
  - **FLEXIBILIDADE**: Usuário pode ajustar agressividade do aprendizado baseado no comportamento do motor
  - **TUNING**: Taxa baixa (0.05) para motores estáveis, taxa alta (0.15) para aprendizado rápido
  - **RESULTADO**: Sistema mais flexível e tunável para diferentes aplicações e preferências do usuário
- **CRITICAL LTIT PHASE VERIFICATION**: LTIT deve verificar se está realmente na fase de marcha lenta antes de aprender:
  - **PROBLEMA**: LTIT estava aprendendo em qualquer fase (Coasting, Running, etc.) desde que RPM estivesse próximo do target
  - **CORREÇÃO**: Verificar `idleController.getCurrentPhase() == IIdleController::Phase::Idling` antes de aprender
  - **IMPLEMENTAÇÃO**: Adicionado getter público `getCurrentPhase()` no IdleController para acesso seguro
  - **RESULTADO**: LTIT só aprende durante marcha lenta real, não durante coast-down ou outras condições
- **CRITICAL LTIT INTEGRATOR THRESHOLD**: Correção da lógica do threshold do integrador PID:
  - **PROBLEMA**: Lógica invertida - LTIT aprendia quando integrador era MENOR que threshold
  - **FÍSICA CORRETA**: Integrador alto indica erro persistente que precisa ser corrigido pelo LTIT
  - **CORREÇÃO**: `if (fabsf(idleIntegral) < minThreshold) return false;` - só aprende se integrador for MAIOR que threshold
  - **RAZÃO**: Integrador baixo significa PID não está trabalhando, não há necessidade de correção LTIT
  - **RESULTADO**: LTIT só aprende quando há realmente erro persistente que justifica correção da tabela
- **CRITICAL LTIT CLOSED LOOP VERIFICATION**: LTIT deve verificar se PID está realmente ativo:
  - **PROBLEMA**: LTIT poderia tentar aprender mesmo em open loop onde integrador não é válido
  - **CORREÇÃO**: Verificar `idleController.useClosedLoop` antes de usar valor do integrador
  - **IMPLEMENTAÇÃO**: Adicionada verificação após validação da fase de marcha lenta
  - **RESULTADO**: LTIT só aprende quando PID está realmente controlando, garantindo integrador válido

# Scratchpad

## ANÁLISE CRÍTICA: PROBLEMA TAU WALL WETTING ADAPTATIVO ⚠️

### PROBLEMA REPORTADO PELO USUÁRIO ⚠️
**Sintoma**: "Tau está sendo corrigido nas células erradas, ou apenas corrigido em situações de desaceleração"

### ANÁLISE DETALHADA DO CÓDIGO ATUAL 🔍

#### 1. LÓGICA DE DETECÇÃO DE TRANSIENTES ✅ CORRETA
**Localização**: `detectTransients()` (linha 294-370)
- **CORRETO**: Ambos transientes (positivos e negativos) iniciam `startImmediatePhase()`
- **CORRETO**: Threshold único de 30 kPa/s para ambos os tipos
- **CORRETO**: Captura condições iniciais para beta em ambos os casos
- **CORRETO**: Reset de condições finais para captura posterior

#### 2. SEQUÊNCIA DE FASES ✅ CORRETA
**Localização**: `updateLambdaResponse()` (linha 854-950)
- **CORRETO**: Fase imediata (0-200ms) → automaticamente inicia fase prolongada
- **CORRETO**: Fase prolongada (dinâmica baseada em 3×tau)
- **CORRETO**: Captura contínua de condições finais durante fase prolongada

#### 3. PERÍODOS DE ADAPTAÇÃO SEPARADOS ⚠️ POSSÍVEL CAUSA
**Localização**: `updateAdaptationMode()` (linha 950-986)
- **PROBLEMA IDENTIFICADO**: Sistema alterna entre ADAPT_BETA_ONLY e ADAPT_TAU_ONLY
- **Configuração atual**: 6 transientes beta → 6 transientes tau → repete
- **POSSÍVEL BIAS**: Se padrão de condução tem mais acelerações que desacelerações, pode parecer que tau só aprende em desacelerações

#### 4. APLICAÇÃO DE CORREÇÕES ✅ CORRETA
**Localização**: `applyCorrectionToTable()` (linha 664-754)
- **CORRETO**: Beta aplicado nas condições iniciais (`initialTransientRpm/Map`)
- **CORRETO**: Tau aplicado nas condições finais (`finalTransientRpm/Map`)
- **CORRETO**: Verificações de NaN e bounds

#### 5. CÁLCULO DE TAU ✅ CORRETA
**Localização**: `calculateTauCorrection()` (linha 570-660)
- **CORRETO**: Análise de regressão linear (slope) em vez de média
- **CORRETO**: Física diferente para aceleração vs desaceleração
- **CORRETO**: Thresholds e proteções adequadas

### POSSÍVEIS CAUSAS DO PROBLEMA ⚠️

#### CAUSA 1: BIAS DOS PERÍODOS DE ADAPTAÇÃO ⚠️
**Problema**: Sistema pode estar em período ADAPT_BETA_ONLY durante acelerações e ADAPT_TAU_ONLY durante desacelerações
**Evidência**: 
- Períodos fixos de 6 transientes cada
- Se padrão de condução tem mais acelerações que desacelerações, tau não aprende nelas
- Se padrão tem mais desacelerações seguidas, beta não aprende nelas

#### CAUSA 2: THRESHOLD DE DETECÇÃO UNIFORME ⚠️
**Problema**: Threshold de 30 kPa/s pode ser inadequado para desacelerações
**Evidência**:
- Desacelerações podem ter magnitude menor que acelerações
- Threshold único pode favorecer detecção de acelerações
- Resultado: Mais transientes de aceleração detectados

#### CAUSA 3: TIMEOUT E INTERRUPÇÕES ⚠️
**Problema**: Transientes sobrepostos podem interromper fase prolongada
**Evidência**:
- Threshold de 50 kPa/s para detecção de interrupção
- `applyIncompleteTransientCorrection()` só aplica beta
- Se acelerações são mais "agressivas", tau nunca completa

#### CAUSA 4: DURAÇÃO DINÂMICA DA FASE PROLONGADA ⚠️
**Problema**: Duração baseada em tau pode ser inadequada
**Evidência**:
- Duração = 3×tau pode ser muito longa para alguns casos
- Timeout de 5s pode ser insuficiente para tau alto
- Fase prolongada pode não completar adequadamente

### DIAGNÓSTICO NECESSÁRIO 🔧

#### LOGGING DETALHADO REQUERIDO:
1. **Contadores por tipo de transiente**: Quantos positivos vs negativos detectados
2. **Períodos de adaptação**: Quando está em BETA_ONLY vs TAU_ONLY
3. **Fases completadas**: Quantas fases prolongadas completam vs interrompem
4. **Correções aplicadas**: Quando beta vs tau são realmente aplicados
5. **Condições de aplicação**: RPM/MAP onde correções são aplicadas

#### TESTES PROPOSTOS:
1. **Forçar ADAPT_BOTH**: Temporariamente permitir ambos beta e tau sempre
2. **Threshold adaptativo**: Diferentes thresholds para aceleração vs desaceleração
3. **Timeout dinâmico**: Baseado no tau atual em vez de fixo
4. **Estatísticas detalhadas**: Contadores de sucesso/falha por tipo

### CORREÇÕES PROPOSTAS 🛠️

#### CORREÇÃO 1: THRESHOLD ADAPTATIVO ✅
```cpp
const float accelThreshold = 30.0f;  // Aceleração: threshold normal
const float decelThreshold = 20.0f;  // Desaceleração: threshold menor
```

#### CORREÇÃO 2: TIMEOUT DINÂMICO ✅
```cpp
float dynamicTimeout = fmaxf(5.0f, m_adaptiveData.currentTau * 4.0f);
```

#### CORREÇÃO 3: MODO ADAPT_BOTH TEMPORÁRIO ✅
```cpp
// Para diagnóstico, forçar adaptação de ambos
m_adaptiveData.currentAdaptationMode = WwAdaptiveData::ADAPT_BOTH;
```

#### CORREÇÃO 4: LOGGING DETALHADO ✅
```cpp
efiPrintf("WW: Transient %s, mode=%s, phase=%s", 
    isPositive ? "ACCEL" : "DECEL",
    getCurrentAdaptationModeString(),
    getCurrentPhaseString());
```

### PLANO DE AÇÃO IMEDIATO 📋

[ ] **PASSO 1**: Implementar logging detalhado para diagnóstico
[ ] **PASSO 2**: Coletar dados de campo sobre padrões de transientes
[ ] **PASSO 3**: Implementar threshold adaptativo
[ ] **PASSO 4**: Implementar timeout dinâmico
[ ] **PASSO 5**: Testar modo ADAPT_BOTH temporariamente
[ ] **PASSO 6**: Ajustar períodos de adaptação baseado nos dados

### CONCLUSÃO PRELIMINAR 📊

**MAIS PROVÁVEL**: O problema não está na lógica fundamental, mas sim nos **períodos de adaptação separados** que podem criar um bias aparente baseado no padrão de condução do usuário.

**SOLUÇÃO IMEDIATA**: Implementar logging detalhado para confirmar a hipótese e depois ajustar os períodos ou implementar threshold adaptativo.

**FÍSICA ESTÁ CORRETA**: A implementação segue corretamente a física do wall wetting, o problema parece ser de timing/scheduling das correções.

## PROBLEMAS CRÍTICOS IDENTIFICADOS NA LÓGICA ATUAL ⚠️